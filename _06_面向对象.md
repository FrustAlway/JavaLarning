# 面向对象

## 概述

### 面向过程—C语言

```java
面向过程最早的一种编程思想,第一个完善的编程思想,从编程的过程角度出发考虑问题,面向过程关注的是程序执行的流程，每一个功能都需要我们亲力亲为。详细到每一处细节。
```

强调———–**我该怎么做**

特点

```java
系统适应能力差,可扩展性差,可维护性低
```

### 面向对象—java语言

含义

```java
面向对象是一种基于面向过程的编程思想;从对象的角度出发考虑问题,将不同的功能存放在不同的对象中,当我们需要使用某一个功能的时候，我们不关心执行的步骤，只需要找到一个能帮我们完成这个功能的实例来帮我们做就可以
```

强调 ——–**我让谁去做**

**前提**

```java
必须在类的基础上完成对象的创建,通过对象调用该类中的功能(方法);而对象,表示当前类的 一个具体的实例

java中只有引用数据类型(类 类型)才能产生对象
```

**好处**

```java
稳定性高,可重用性高,易于开发大型产品,具有良好的维护性
可以解决程序耦合度高的问题，低内聚，高耦合
```

**开闭原则**

```java
对扩展开放，对修改关系开放。
在不影响软件的基础功能的前提下，对程序进行平滑的扩展
```

## 类,  对象  类成员

### 概念解释

类

```java
某一类事务的抽象概念,是一个模子（将现实生活中一类事物抽象成我们java中类的概念）
最小的程序单位是"类"----类是面向对象思想中最小的单位
关键字————class
我们写程序就是在写类
"类是对象的模版，对象是类的实例"
类，是引用数据类型，每创建一个类，就相当于我们自己申明了一种数据类型
```

对象

```java
符合某一类事务的具体的实例
类和对象是互推的关系
"类是对象的模版，对象是类的实例"
```

类成员

```java
能够在类中能定义的内容
包括:
	成员变量(属性 全局变量)--描述该类事物
    成员方法--该类事务所具备的功能(能力)
	构造器(构造方法)--用来实例化对象
```

### **类和类成员的定义格式**

```java
类:[访问权限修饰符] [修饰符(一般只有一个)] class 类名{
    
    //成员属性
    [访问权限修饰符] [修饰符(可以有多个)] 数据类型 属性名[ =值 ];//其中的值可写可不写
    
    
    //构造器(构造方法)  格式是固定的
    [访问权限修饰符] 类名([参数列表]){}//参数列表可写可不写
   
    
    //成员方法--------成员方法不用static修饰
    [访问权限修饰符][修饰符("不是static")] 返回值类型 方法名([参数列表])[throws异常类][{
        方法体;
        [return 返回值结果;]
    }]
    
}

```

简单代码展示类的定义方式

```java
//定义了一个   人的类
public class ren{
    //定义了一个方法
    public static void main(String[] args){
        //现在是有一个操作,人 开门,在人这个类中,打开一扇门,
        
		//以往学习的方式是:  men.open();门表示一类,实际中,不可能打开一类门或者购买一类东西,应该具体化,具体到某个物体身上,就是只能获取一个,指定的一个,不推荐使用类来类来调用方法,应该用一个具体的对象调用
        创建(实例化)门的具体对象;
        对象.open();
    }
}

//定义了一个   门的类
public class men{
    
}
```

**注意**

```java
类中可以定义无限个类成员,只要有需求
```

### 构造方法

*构造方法也是方法,是一种特殊的方法*    ———-alt  +   inster
**构造器和方法对比**

```java
没有返回值
名称必须和类名一样   (构造器-----构造方法)--------特点
```

**构造器的作用**

```java
"创建对象的(也可以在创建对象的过程中为对象同时赋初始值)"
    
类在创建好之后,就会将成员属性和成员方法一并申明出来并且附上初始值,但是我们在实际开发中不会使用默认值,我们也可以用构造方法在创建对象后,为对象的属性赋值------值传递
```

**注意1**

```java
构造方法的方法名必须和类名相同，大小也相同

构造方法没有返回值类型，不可以用void占位

构造方法不能return一个具体的值
```

**注意2**

```java
需要在其它类中,给当前类属性设置值,可以定义对应属性的有参构造器完成
    1:有参构造器中参数定义的顺序,要和成员属性定义顺序一致
	2:有参构造器中参数的名字,一般和成员属性名一致
构造方法可以重载(必须是得在同一个类中)
```



### **成员变量和局部变量**

```java
成员变量：----必须在类里，方法的外面
				尽量不要写static关键字
				不初始化----初值：String ：null
    							char：空格（一个字符）
								double：0.0
								int：0
    							boolean：false
java中没有真正的全局变量，可以理解成员变量就是我们的全局变量
```



```java
局部变量：
    	局部变量在使用前必须初始化（赋值）
		而且只能在方法的内部使用
```

**类中全局变量和局部变量的区别**

```java
定义的位置不同:
	局部变量定义在方法内部(参数中),成员变量定义在类中-----类中有方法

作用域不同:
	局部变量只能在定义的方法内部区使用,成员变量(全局变量)可以整个类通用
	
默认值不同:
	局部变量没有默认值,在设置局部变量的时候必须初始化,给他赋初值,成员变量如果没有手动为期赋值的情况下,是有默认值的,上面写了.(方法的形参就是一个局部变量,传递参数的过程就是为了变量赋值的过程)

内存位置不同:
	局部变量在栈内存中,成员变量在堆内存中

生命周期不同:
	局部变量在栈内存中,随着方法的进栈诞生,方法的出栈消失
	成员变量在堆内存中,随着类的创建去创建,知道成为垃圾后被垃圾回收机制回收.

```



### 关键字:this

用法:

```java
当成员属性名  和  参数属性名  一致的时候,并且使用（局部属性）参数属性给成员属性赋值,通过this.成员属性 = 局部属性,进行区分
```

表示:

```java
当前类对象
```

**理解**

```java
其中，这个用this.的方法进行赋值,是多用在有参构造器中的,this的作用是为了给成员属性赋值,而不是给他本身赋值,所以用this.进行区分.(编程采用就近原则,不用this区分的话,会找到同名的其它参数,而不是成员中要找的名字(成员属性).所以在编程的时候,需要指定的操作完成同名的区分)
```

**等价代换**

```java
如果不使用有参构造器的话，会使用
Person p = new Person（）;－－－－实例化对象
p.name  =  name；
这个和this.是一样的，通过实例化对象，然后通过.的方式进行赋值，一般无参的时候就可以用这个方式进行实例化然后赋值。
```

注意——–使用“this.”

```java
使用传递参数给成员赋值

当成员属性名和参数属性名一致的时候,不能直接编写     成员属性名 =  参数属性名-----name = name;错误的

"this."  必须在方法体中使用
```

**this的三种用法**

在子类构造方法中,使用this(参数列表)调用本类的构造方法

在子类中,使用 this. 属性名  调用的是本类的属性

在子类中, 使用this.方法名  调用的是本类的方法名









## 对象

对象创建在堆内存中(每个对象都有自己的属性和行为)

对象的产生————声明    和   实例化

运行程序就是在运行对象

对象就是现实生活中真实存在的个体，是具体的概念。

需要使用（构造器，构造函数，构造方法）才可以创建对象。

**声明**

```java
数据类型 对象名;

public Worker worker;
```

**实例化**（就是创建对象的方法）

```java
数据类型 对象名 = new 数据类型([参数列表]);
类名  引用名 = new 类名（）;
```

调用对象成员属性：对象引用名.属性名  的方式调用

调用对象的成员方法:  对象引用名.方法名 的方式调用

**声明和实例化的区别**

```java
个数不同:
	声明:只在栈内存声明一个类的对象 
	实例化:即在栈内存创建对象,同时也通过new关键字将地址指向堆内存

能否直接应用:
	声明的对象:不能应用,会报错,空指针(空指向)异常
	实例化对象:可以直接使用
```

**特殊的引用数据类型**  ———  **数组**

```java
除了可以通过new 关键字发生地址指向的改变还能通过 = 发生地址指向的改变
```

### 成员属性

**作用**

```java
用来描述一类事务 或者一个具体的对象

叫法: 
	全局属性 ;全局变量;成员字段(Field,javaBean规范讲解);成员变量
```

**成员常量**

已经在开头中提到成员常量和定义方式
**分类**

按照作用域划分

```java
局部变量:作用于指定的代码块中
局部变量定义在代码块中的时候必须定义初始值,否则不能调用

成员变量:作用于 整个类
```

按照动静态划分

```java
成员变量--实际开发中操作最多;值会根据不同的用户(不同的条件),进行不同的赋值

成员常量--数据值(final)和存储位置static都相对稳定,实际开发中没有特殊要求,一般不定义成员常量
```











## 编程规范 JavaBean规范

```java
分包

主函数中,只有两步操作
	实例化对象
    对象.调用方法   调用成员字段,成员属性
    
在没有特殊要求的时候,所有的成员字段,均用private作为访问权限修饰符
    
在没有特殊要求的时候,所有的成员方法(包括构造器)都用public作为访问权限修饰符

```

**JavaBean**

含义

```java
符合指定定义规范(或规范)的java类的统称;以后编码的时候只要看到了bean这个词,表示需要配置java类
```

在javaBean中能够定义的内容:

```java
属性(property) 
字段(Field)
方法(Method)
事件(Event)
```

如何区分属性和属性字段

```java
字段(Field):java类中 被访问权限修饰符 修饰的变量----一定是成员变量
属性(property):----java中指定字段的get/set方法去掉get/set之后,单词首字母小写 和成员字段名一致,称呼为属性
```

拓展:当成员字段的数据类型是boolean时候,其对应的get方法会变为isXxx()—有的时候是编辑器引起的,有的不是



## 访问权限修饰符

访问权限修饰符的分类———-类的访问权限修饰符     和     类成员的访问权限修饰符

### 类的访问权限修饰符

public     和     缺省(在java中不常用缺省,C语言常用)
```java
在同一个 .java文件中,支持定义多个类(实际开发中,不推荐这么写,会受到访问权限的影响)
```

**注意**

```java
类名不能相同
只有一个类可以被public修饰,其余的都是缺省
是否任意的类,都可以被public修饰呢?----错,只有"类名"和 .java文件名同名的类,必须使用public作为访问权限修饰符
```



### 类成员的访问权限修饰符

作用范围从大到小

|      作用范围       | 本类 | 同包 | 子类/自包 | 任意 |
| :-----------------: | :--: | :--: | :-------: | :--: |
|   public(共有的)    |  *   |  *   |     *     |  *   |
| protected(受保护的) |  *   |  *   |     *     |      |
|        缺省         |  *   |  *   |           |      |
|   private(私有的)   |  *   |      |           |      |



## 修饰符

(实际开发中,如果没有特殊要求,一般的时候不写)

### static

**相关概念**

静态的,指被修饰的内容,位置相对稳定

一旦被static修饰,那么被修饰的内容将不属于自身,而是属于该类,本类对象共享这个被static修饰的这个部分

**能够修饰**

```java
成员属性
成员方法
静态代码块
```

**特点**

```java
被static修饰的成员属性  成员字段,"可以直接通过   类名.   调用"
    
主要还是和类有关,和对象无关
静态的成员在类被加载的同时就被创建。
那么也就意味着他是优于对象先创建的。所以被 static 修饰的是优于对象创建。
静态是优于非静态所创建。

优先主函数加载,并且在程序整个执行过程中只加载一次(在第一次开启被加载)

在静态的代码块中调用其它类成员,则,该列成员也必须是静态的.(同类型调用)


而且,在方法中对static的内容进行赋值后,那么后面的调用static的语句内容,都将会是最后一次被赋值后的数值.

静态方法中不能有  this  和  super  关键字
    
    
```

代码块

```java
static{
    
}
```

为什么不是所有的类成员都用  static 修饰

```java
好处:可以通过  类名.  调用,省去  创建对象,造成内存空间的浪费的浪费操作

不足:由于被static修饰,类成员的位置相对稳定,不利于JVM虚拟机的清除,因此在实际开发中不推荐使用
```



在同一个类中：当静态方法和成员方法相互调用时

```java
静态方法不能直接调用成员方法
    因为再有静态方法的时候,成员方法还没有被加载(加载顺序的问题)

成员方法可以直接调用静态方法
    
静态方法可以直接调用静态方法

成员方法可以直接调用成员方法
```



**静态方法的注意事项**

```java
- 在类中，除了声明语句外，不能定义其他的独立语句。若想定义必须定义在代码块中

- 语句块是优于构造方法先执行的。(就是代码块,用"{}"进行单独书写,没有访问权限修饰符,没有发返回类型,没有名字,只有一个 static 或者什么都没有)


    
无论是成员变量还是成员方法，当被 static 关键字修饰后，那么都可以通过  类名.属性||方法 名的方式调用。（若在被类中调用可以省略类名）。

- 静态只能访问静态，不能直接访问非静态；（加载顺序）
- 静态中不能使用 this super 关键字。
- 静态的属性及方法被改类的所有对象共享
```











### abstract

(抽象的)

**修饰过后**

```java
类:不能通过new关键字来实例化对象
成员方法:没有方法体
```



格式

```java
[访问权限修饰符] abstract class 类名{ }
```

抽象方法:  没有方法体的方法我们称之为抽象方法

```java
抽象方法就是用来被继承的，

如果一个类继承了一个抽象类，那么必须实现里面所有的抽象方法，（实现关键字：implements）
    
如果没有吧所有的抽象方法重写，那么这个类还是一个抽象类
```





抽象类中一定存在抽象方法么?

```java
不是,抽象类中可以没有抽象方法(就是可以定义普通方法----有方法体的方法)

但是有抽象方法的类,一定是抽象类
```



**抽象类的特点:**

```java
抽象类是类,是类就可以存在构造方法
    
但是抽象类不能被实例化(因为可能存在抽象方法.抽象方法没有方法体,所以不知道该执行什么)
```











### final

(最终的)

**修饰后**

```java
类:不能被继承(没有子类)
成员字段:要求必须定义初始值
成员方法:不能被重写
```



如果定义最终变量没有被赋值,我 们可以使用有参构造方法的方式去赋值,但是被赋值后将无法改变

```java
public class Student{
    public final String NAME;
    
    public Student(String name){
        this.NAME = name;
    }
}
```

总之,被final 修饰的内容,初始值赋值之后,就无法改变内容了.

而且被final修饰的**“引用数据类”**型将不能改变地址(但是可以改变引用数据类型里面的值)

**abstract 和 final 的区别**
final 是不能被类继承或重写，abstract 就是让类去继承或重写。 所以他俩是互斥的。不能同时出现。实际开发中不推荐使用抽象类。而是接口。



**注意**

```java
常用于和 static 配合使用,定义的是成员常量

    
被 final 修饰的变量将成为常量。不可修改。命名方式为全部大写！。多个单词组成由_区分。 FIRST_NAME

被 final 修饰的成员方法变为最终方法，该方法不能被重写。
	被修饰的类是不能被继承的

static 保证位置相对不动，  final保证值相对不动
```

*常量见文章开头的定义格式*



### synchronized

(特点: 同步)

**修饰什么**

```java
成员方法   和  代码块
```



**修饰符的总结**

| 修饰符       | 含义 | 能够修饰什么       | 特征                                                         |
| ------------ | ---- | ------------------ | ------------------------------------------------------------ |
| static       | 静态 | 方法、属性、代码块 | 类名.的方法就可以直接调用。被静态修饰的由于成员先执行。他与对象无关，与类有关 |
| final        | 最终 | 类、属性、方法     | 类：不能被继承、属性：值不能被改变。方法：不能被重写         |
| abstract     | 抽象 | 类、方法           | 类：不能实例化。方法：没有方法体                             |
| synchronized | 同步 | 方法、代码块       | 同一时间只能做一个操作。同步的。                             |



## 总结步骤

1.先编写domain包下的实体类———符合JvaBean规范

```java
1.根据用户需求定义成员字段,并且全部私有化
2.定义对应类的  "有参"  和   "无参"  构造器
3.定义对应所有字段的"get/set"方法
4.根据用户的实际需求,判断是否需要定义toString方法----打印类的信息
5.根据用户需求,定义成员方法
```



2.编写test包的测试类

```java
编写主函数,调用方法进行测试
```

## 总结2

```
类
    相同属性和方法的一组"对象"的集合
    
对象
    描述客观事物的实体,有"一组属性和方法"构成
    
属性(成员变量,局部变量)
    "对象"具有的各种特征
    
方法(方法调用,方法重载)
    对象执行的操作,或者说是"对象具有的功能",是程序中最小的执行单元
    
值传递
```